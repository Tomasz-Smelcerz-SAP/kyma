
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kyma-project/kyma/components/application-gateway/internal/apperrors/apperrors.go (100.0%)</option>
				
				<option value="file1">github.com/kyma-project/kyma/components/application-gateway/internal/authorization/basicauthstrategy.go (100.0%)</option>
				
				<option value="file2">github.com/kyma-project/kyma/components/application-gateway/internal/authorization/certificategenstrategy.go (100.0%)</option>
				
				<option value="file3">github.com/kyma-project/kyma/components/application-gateway/internal/authorization/csrf/csrf.go (93.3%)</option>
				
				<option value="file4">github.com/kyma-project/kyma/components/application-gateway/internal/authorization/csrf/csrfclient.go (0.0%)</option>
				
				<option value="file5">github.com/kyma-project/kyma/components/application-gateway/internal/authorization/csrf/csrftokencache.go (100.0%)</option>
				
				<option value="file6">github.com/kyma-project/kyma/components/application-gateway/internal/authorization/externaltokenstrategy.go (100.0%)</option>
				
				<option value="file7">github.com/kyma-project/kyma/components/application-gateway/internal/authorization/factory.go (78.6%)</option>
				
				<option value="file8">github.com/kyma-project/kyma/components/application-gateway/internal/authorization/noauthstrategy.go (100.0%)</option>
				
				<option value="file9">github.com/kyma-project/kyma/components/application-gateway/internal/authorization/oauth/oauthclient.go (93.2%)</option>
				
				<option value="file10">github.com/kyma-project/kyma/components/application-gateway/internal/authorization/oauth/tokencache/tokencache.go (100.0%)</option>
				
				<option value="file11">github.com/kyma-project/kyma/components/application-gateway/internal/authorization/oauthstrategy.go (100.0%)</option>
				
				<option value="file12">github.com/kyma-project/kyma/components/application-gateway/internal/externalapi/errorhandler.go (100.0%)</option>
				
				<option value="file13">github.com/kyma-project/kyma/components/application-gateway/internal/externalapi/externalapi.go (0.0%)</option>
				
				<option value="file14">github.com/kyma-project/kyma/components/application-gateway/internal/externalapi/healthcheckhandler.go (100.0%)</option>
				
				<option value="file15">github.com/kyma-project/kyma/components/application-gateway/internal/k8sconsts/nameresolver.go (100.0%)</option>
				
				<option value="file16">github.com/kyma-project/kyma/components/application-gateway/internal/metadata/applications/repository.go (61.5%)</option>
				
				<option value="file17">github.com/kyma-project/kyma/components/application-gateway/internal/metadata/secrets/repository.go (100.0%)</option>
				
				<option value="file18">github.com/kyma-project/kyma/components/application-gateway/internal/metadata/serviceapi/serviceapiservice.go (95.5%)</option>
				
				<option value="file19">github.com/kyma-project/kyma/components/application-gateway/internal/metadata/servicedefservice.go (100.0%)</option>
				
				<option value="file20">github.com/kyma-project/kyma/components/application-gateway/internal/proxy/cache.go (91.7%)</option>
				
				<option value="file21">github.com/kyma-project/kyma/components/application-gateway/internal/proxy/proxy.go (98.1%)</option>
				
				<option value="file22">github.com/kyma-project/kyma/components/application-gateway/internal/proxy/proxyfactory.go (78.6%)</option>
				
				<option value="file23">github.com/kyma-project/kyma/components/application-gateway/internal/proxy/unauthorizedresponseretrier.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package apperrors

import "fmt"

const (
        CodeInternal                 = 1
        CodeNotFound                 = 2
        CodeAlreadyExists            = 3
        CodeWrongInput               = 4
        CodeUpstreamServerCallFailed = 5
)

type AppError interface {
        Code() int
        Error() string
}

type appError struct {
        code    int
        message string
}

func errorf(code int, format string, a ...interface{}) AppError <span class="cov8" title="1">{
        return appError{code: code, message: fmt.Sprintf(format, a...)}
}</span>

func Internal(format string, a ...interface{}) AppError <span class="cov8" title="1">{
        return errorf(CodeInternal, format, a...)
}</span>

func NotFound(format string, a ...interface{}) AppError <span class="cov8" title="1">{
        return errorf(CodeNotFound, format, a...)
}</span>

func AlreadyExists(format string, a ...interface{}) AppError <span class="cov8" title="1">{
        return errorf(CodeAlreadyExists, format, a...)
}</span>

func WrongInput(format string, a ...interface{}) AppError <span class="cov8" title="1">{
        return errorf(CodeWrongInput, format, a...)
}</span>

func UpstreamServerCallFailed(format string, a ...interface{}) AppError <span class="cov8" title="1">{
        return errorf(CodeUpstreamServerCallFailed, format, a...)
}</span>

func (ae appError) Code() int <span class="cov8" title="1">{
        return ae.code
}</span>

func (ae appError) Error() string <span class="cov8" title="1">{
        return ae.message
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package authorization

import (
        "net/http"

        "github.com/kyma-project/kyma/components/application-gateway/internal/authorization/util"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
)

type basicAuthStrategy struct {
        username string
        password string
}

func newBasicAuthStrategy(username, password string) basicAuthStrategy <span class="cov8" title="1">{
        return basicAuthStrategy{
                username: username,
                password: password,
        }
}</span>

func (b basicAuthStrategy) AddAuthorization(r *http.Request, _ TransportSetter) apperrors.AppError <span class="cov8" title="1">{
        util.AddBasicAuthHeader(r, b.username, b.password)
        return nil
}</span>

func (b basicAuthStrategy) Invalidate() {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package authorization

import (
        "crypto/tls"
        "net/http"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
)

type certificateGenStrategy struct {
        certificate []byte
        privateKey  []byte
}

func newCertificateGenStrategy(certificate, privateKey []byte) certificateGenStrategy <span class="cov8" title="1">{
        return certificateGenStrategy{
                certificate: certificate,
                privateKey:  privateKey,
        }
}</span>

func (b certificateGenStrategy) AddAuthorization(r *http.Request, setter TransportSetter) apperrors.AppError <span class="cov8" title="1">{
        cert, err := b.prepareCertificate()
        if err != nil </span><span class="cov8" title="1">{
                return apperrors.Internal("Failed to prepare certificate, %s", err.Error())
        }</span>

        <span class="cov8" title="1">transport := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        Certificates: []tls.Certificate{cert},
                },
        }

        setter(transport)

        return nil</span>
}

func (b certificateGenStrategy) Invalidate() {<span class="cov0" title="0">
}</span>

func (b certificateGenStrategy) prepareCertificate() (tls.Certificate, error) <span class="cov8" title="1">{
        return tls.X509KeyPair(b.certificate, b.privateKey)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package csrf

import (
        "net/http"

        "github.com/kyma-project/kyma/components/application-gateway/internal/httpconsts"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        "github.com/kyma-project/kyma/components/application-gateway/internal/authorization"
        log "github.com/sirupsen/logrus"
)

type TokenStrategyFactory interface {
        Create(authorizationStrategy authorization.Strategy, csrfTokenEndpointURL string) TokenStrategy
}

type TokenStrategy interface {
        //Sets CSRF Token into requests to external APIs
        AddCSRFToken(apiRequest *http.Request) apperrors.AppError

        //Invalidates cached CSRF Token
        Invalidate()
}

type strategyFactory struct {
        csrfClient Client
}

type strategy struct {
        authorizationStrategy authorization.Strategy
        csrfTokenURL          string
        csrfClient            Client
}

func NewTokenStrategyFactory(csrfClient Client) TokenStrategyFactory <span class="cov8" title="1">{
        return &amp;strategyFactory{csrfClient}
}</span>

func (tsf *strategyFactory) Create(authorizationStrategy authorization.Strategy, csrfTokenEndpointURL string) TokenStrategy <span class="cov8" title="1">{
        if csrfTokenEndpointURL == "" </span><span class="cov8" title="1">{
                //TODO: DEBUG
                log.Print("CSRF Token not configured!")
                return &amp;noTokenStrategy{}
        }</span>
        <span class="cov8" title="1">return &amp;strategy{authorizationStrategy, csrfTokenEndpointURL, tsf.csrfClient}</span>
}

func (s *strategy) AddCSRFToken(apiRequest *http.Request) apperrors.AppError <span class="cov8" title="1">{

        tokenResponse, err := s.csrfClient.GetTokenEndpointResponse(s.csrfTokenURL, s.authorizationStrategy)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("failed to get CSRF token : '%s'", err)
                return err
        }</span>

        <span class="cov8" title="1">apiRequest.Header.Set(httpconsts.HeaderCSRFToken, tokenResponse.CSRFToken)
        for _, cookie := range tokenResponse.Cookies </span><span class="cov8" title="1">{
                apiRequest.AddCookie(cookie)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *strategy) Invalidate() <span class="cov0" title="0">{
        s.csrfClient.InvalidateTokenCache(s.csrfTokenURL)
}</span>

type noTokenStrategy struct{}

func (nts *noTokenStrategy) AddCSRFToken(apiRequest *http.Request) apperrors.AppError <span class="cov8" title="1">{
        return nil
}</span>

func (nts *noTokenStrategy) Invalidate() {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package csrf

import (
        "context"
        "log"
        "net/http"
        "strings"
        "time"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        "github.com/kyma-project/kyma/components/application-gateway/internal/authorization"
        "github.com/kyma-project/kyma/components/application-gateway/internal/httpconsts"
)

type Response struct {
        CSRFToken string
        Cookies   []*http.Cookie
}

type Client interface {
        GetTokenEndpointResponse(csrfEndpointURL string, strategy authorization.Strategy) (*Response, apperrors.AppError)
        InvalidateTokenCache(csrfEndpointURL string)
}

type client struct {
        timeoutDuration int
        tokenCache      TokenCache
}

func NewCSRFClient(timeoutDuration int, tokenCache TokenCache) Client <span class="cov0" title="0">{
        return &amp;client{
                timeoutDuration: timeoutDuration,
                tokenCache:      tokenCache,
        }
}</span>

func (c *client) GetTokenEndpointResponse(csrfEndpointURL string, strategy authorization.Strategy) (*Response, apperrors.AppError) <span class="cov0" title="0">{

        resp, found := c.tokenCache.Get(csrfEndpointURL)
        if found </span><span class="cov0" title="0">{
                //TODO: DEBUG
                log.Printf("Found cached Token Response: %#v", resp)
                return resp, nil
        }</span>

        <span class="cov0" title="0">tokenResponse, err := c.requestToken(csrfEndpointURL, strategy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.tokenCache.Add(csrfEndpointURL, tokenResponse)

        return tokenResponse, nil</span>

}

func (c *client) InvalidateTokenCache(csrfEndpointURL string) <span class="cov0" title="0">{
        c.tokenCache.Remove(csrfEndpointURL)
}</span>

func (c *client) requestToken(csrfEndpointURL string, strategy authorization.Strategy) (*Response, apperrors.AppError) <span class="cov0" title="0">{

        //TODO: DEBUG
        log.Printf("requestToken: csrfEndpointURL=%s", csrfEndpointURL)

        client := &amp;http.Client{}

        tokenRequest, err := http.NewRequest(http.MethodGet, csrfEndpointURL, strings.NewReader(""))
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.Internal("failed to create token request: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = addAuthorization(tokenRequest, client, strategy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.Internal("failed to create token request: %s", err.Error())
        }</span>

        <span class="cov0" title="0">setCSRFSpecificHeaders(tokenRequest)

        ctx, cancel := context.WithTimeout(context.Background(), time.Duration(c.timeoutDuration)*time.Second)
        defer cancel()
        requestWithContext := tokenRequest.WithContext(ctx)

        resp, err := client.Do(requestWithContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.UpstreamServerCallFailed("failed to make a request to '%s': %s", csrfEndpointURL, err.Error())
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, apperrors.UpstreamServerCallFailed("incorrect response code '%d' while getting token from %s", resp.StatusCode, csrfEndpointURL)
        }</span>

        <span class="cov0" title="0">tokenRes := &amp;Response{
                CSRFToken: resp.Header.Get(httpconsts.HeaderCSRFToken),
                Cookies:   resp.Cookies(),
        }

        //TODO: DEBUG
        log.Printf("Token Response: %#v", tokenRes)

        return tokenRes, nil</span>

}

func addAuthorization(r *http.Request, client *http.Client, strategy authorization.Strategy) apperrors.AppError <span class="cov0" title="0">{
        return strategy.AddAuthorization(r, func(transport *http.Transport) </span><span class="cov0" title="0">{
                client.Transport = transport
        }</span>)
}

func setCSRFSpecificHeaders(r *http.Request) <span class="cov0" title="0">{
        r.Header.Add(httpconsts.HeaderCSRFToken, httpconsts.HeaderCSRFTokenVal)
        r.Header.Add(httpconsts.HeaderAccept, httpconsts.HeaderAcceptVal)
        r.Header.Add(httpconsts.HeaderCacheControl, httpconsts.HeaderCacheControlVal)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package csrf

import (
        "time"

        cache "github.com/patrickmn/go-cache"
)

type TokenCache interface {
        Get(itemID string) (resp *Response, found bool)
        Add(itemID string, resp *Response)
        Remove(itemID string)
}

type tokenCache struct {
        cache *cache.Cache
}

func NewTokenCache() TokenCache <span class="cov8" title="1">{
        return &amp;tokenCache{
                cache: cache.New(cache.NoExpiration, cache.NoExpiration),
        }
}</span>

func (tc *tokenCache) Get(itemID string) (resp *Response, found bool) <span class="cov8" title="1">{
        res, found := tc.cache.Get(itemID)
        if !found </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">return res.(*Response), found</span>
}

func (tc *tokenCache) Add(itemID string, resp *Response) <span class="cov8" title="1">{
        tc.cache.Set(itemID, resp, time.Duration(-1)*time.Second)
}</span>

func (tc *tokenCache) Remove(itemID string) <span class="cov8" title="1">{
        tc.cache.Delete(itemID)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package authorization

import (
        "net/http"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        "github.com/kyma-project/kyma/components/application-gateway/internal/httpconsts"
)

type externalTokenStrategy struct {
        strategy Strategy
}

func newExternalTokenStrategy(strategy Strategy) Strategy <span class="cov8" title="1">{
        return externalTokenStrategy{strategy: strategy}
}</span>

func (e externalTokenStrategy) AddAuthorization(r *http.Request, setter TransportSetter) apperrors.AppError <span class="cov8" title="1">{
        externalToken := r.Header.Get(httpconsts.HeaderAccessToken)

        if externalToken != "" </span><span class="cov8" title="1">{
                r.Header.Del(httpconsts.HeaderAccessToken)
                r.Header.Set(httpconsts.HeaderAuthorization, externalToken)

                return nil
        }</span><span class="cov8" title="1"> else {
                return e.strategy.AddAuthorization(r, setter)
        }</span>
}

func (o externalTokenStrategy) Invalidate() <span class="cov8" title="1">{
        o.strategy.Invalidate()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package authorization

import (
        "net/http"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        "github.com/kyma-project/kyma/components/application-gateway/internal/authorization/oauth"
        "github.com/kyma-project/kyma/components/application-gateway/internal/authorization/oauth/tokencache"
        metadatamodel "github.com/kyma-project/kyma/components/application-gateway/internal/metadata/model"
)

type Strategy interface {
        // Adds Authorization header to the request
        AddAuthorization(r *http.Request, setter TransportSetter) apperrors.AppError
        // Invalidates internal state
        Invalidate()
}

type TransportSetter func(transport *http.Transport)

type StrategyFactory interface {
        // Creates strategy for credentials provided
        Create(credentials *metadatamodel.Credentials) Strategy
}

type OAuthClient interface {
        // GetToken obtains OAuth token
        GetToken(clientID string, clientSecret string, authURL string) (string, apperrors.AppError)
        // InvalidateTokenCache resets internal token cache
        InvalidateTokenCache(clientID string)
}

type authorizationStrategyFactory struct {
        oauthClient OAuthClient
}

// Create creates strategy for credentials provided
func (asf authorizationStrategyFactory) Create(c *metadatamodel.Credentials) Strategy <span class="cov8" title="1">{

        if c != nil &amp;&amp; c.OAuth != nil </span><span class="cov8" title="1">{
                oauthStrategy := newOAuthStrategy(asf.oauthClient, c.OAuth.ClientID, c.OAuth.ClientSecret, c.OAuth.URL)

                return newExternalTokenStrategy(oauthStrategy)
        }</span><span class="cov8" title="1"> else if c != nil &amp;&amp; c.BasicAuth != nil </span><span class="cov8" title="1">{
                basicAuthStrategy := newBasicAuthStrategy(c.BasicAuth.Username, c.BasicAuth.Password)

                return newExternalTokenStrategy(basicAuthStrategy)
        }</span><span class="cov8" title="1"> else if c != nil &amp;&amp; c.CertificateGen != nil </span><span class="cov8" title="1">{
                certificateGenStrategy := newCertificateGenStrategy(c.CertificateGen.Certificate, c.CertificateGen.PrivateKey)

                return newExternalTokenStrategy(certificateGenStrategy)
        }</span><span class="cov8" title="1"> else {
                noAuthStrategy := newNoAuthStrategy()

                return newExternalTokenStrategy(noAuthStrategy)
        }</span>
}

// Factory configuration options
type FactoryConfiguration struct {
        OAuthClientTimeout int
}

// NewStrategyFactory creates factory for instantiating Strategy implementations
func NewStrategyFactory(config FactoryConfiguration) StrategyFactory <span class="cov0" title="0">{
        cache := tokencache.NewTokenCache()
        oauthClient := oauth.NewOauthClient(config.OAuthClientTimeout, cache)

        return authorizationStrategyFactory{oauthClient: oauthClient}
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package authorization

import (
        "net/http"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
)

func newNoAuthStrategy() noAuthStrategy <span class="cov8" title="1">{
        return noAuthStrategy{}
}</span>

type noAuthStrategy struct {
}

func (ns noAuthStrategy) AddAuthorization(_ *http.Request, _ TransportSetter) apperrors.AppError <span class="cov8" title="1">{
        return nil
}</span>

func (ns noAuthStrategy) Invalidate() {<span class="cov0" title="0">

}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package oauth

import (
        "context"
        "crypto/tls"
        "encoding/json"
        "io/ioutil"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/kyma-project/kyma/components/application-gateway/internal/authorization/util"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        "github.com/kyma-project/kyma/components/application-gateway/internal/authorization/oauth/tokencache"
        "github.com/kyma-project/kyma/components/application-gateway/internal/httpconsts"
)

type oauthResponse struct {
        AccessToken string `json:"access_token"`
        TokenType   string `json:"token_type"`
        ExpiresIn   int    `json:"expires_in"`
        Scope       string `json:"scope"`
}

type Client interface {
        GetToken(clientID string, clientSecret string, authURL string) (string, apperrors.AppError)
        InvalidateAndRetry(clientID string, clientSecret string, authURL string) (string, apperrors.AppError)
        InvalidateTokenCache(clientID string)
}

type client struct {
        timeoutDuration int
        tokenCache      tokencache.TokenCache
}

func NewOauthClient(timeoutDuration int, tokenCache tokencache.TokenCache) Client <span class="cov8" title="1">{
        return &amp;client{
                timeoutDuration: timeoutDuration,
                tokenCache:      tokenCache,
        }
}</span>

func (c *client) GetToken(clientID string, clientSecret string, authURL string) (string, apperrors.AppError) <span class="cov8" title="1">{
        token, found := c.tokenCache.Get(clientID)
        if found </span><span class="cov8" title="1">{
                return token, nil
        }</span>

        <span class="cov8" title="1">tokenResponse, err := c.requestToken(clientID, clientSecret, authURL)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">c.tokenCache.Add(clientID, tokenResponse.AccessToken, tokenResponse.ExpiresIn)

        return tokenResponse.AccessToken, nil</span>
}

func (c *client) InvalidateAndRetry(clientID string, clientSecret string, authURL string) (string, apperrors.AppError) <span class="cov8" title="1">{
        c.tokenCache.Remove(clientID)

        tokenResponse, err := c.requestToken(clientID, clientSecret, authURL)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">c.tokenCache.Add(clientID, tokenResponse.AccessToken, tokenResponse.ExpiresIn)

        return tokenResponse.AccessToken, nil</span>
}

func (c *client) InvalidateTokenCache(clientID string) <span class="cov0" title="0">{
        c.tokenCache.Remove(clientID)
}</span>

func (c *client) requestToken(clientID string, clientSecret string, authURL string) (*oauthResponse, apperrors.AppError) <span class="cov8" title="1">{
        transport := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},
        }
        client := &amp;http.Client{Transport: transport}

        form := url.Values{}
        form.Add("client_id", clientID)
        form.Add("client_secret", clientSecret)
        form.Add("grant_type", "client_credentials")

        req, err := http.NewRequest(http.MethodPost, authURL, strings.NewReader(form.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.Internal("failed to create token request: %s", err.Error())
        }</span>

        <span class="cov8" title="1">util.AddBasicAuthHeader(req, clientID, clientSecret)
        req.Header.Add(httpconsts.HeaderContentType, httpconsts.ContentTypeApplicationURLEncoded)

        ctx, cancel := context.WithTimeout(context.Background(), time.Duration(c.timeoutDuration)*time.Second)
        defer cancel()
        requestWithContext := req.WithContext(ctx)

        response, err := client.Do(requestWithContext)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperrors.UpstreamServerCallFailed("failed to make a request to '%s': %s", authURL, err.Error())
        }</span>

        <span class="cov8" title="1">if response.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, apperrors.UpstreamServerCallFailed("incorrect response code '%d' while getting token from %s", response.StatusCode, authURL)
        }</span>

        <span class="cov8" title="1">body, err := ioutil.ReadAll(response.Body)
        defer response.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.UpstreamServerCallFailed("failed to read token response body from '%s': %s", authURL, err.Error())
        }</span>

        <span class="cov8" title="1">tokenResponse := &amp;oauthResponse{}

        err = json.Unmarshal(body, tokenResponse)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperrors.UpstreamServerCallFailed("failed to unmarshal token response body: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return tokenResponse, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package tokencache

import (
        "time"

        cache "github.com/patrickmn/go-cache"
)

type TokenCache interface {
        Get(clientID string) (token string, found bool)
        Add(clientID, token string, expirationSeconds int)
        Remove(clientID string)
}

type tokenCache struct {
        cache *cache.Cache
}

func NewTokenCache() TokenCache <span class="cov8" title="1">{
        return &amp;tokenCache{
                cache: cache.New(cache.NoExpiration, cache.NoExpiration),
        }
}</span>

func (tc *tokenCache) Get(clientId string) (token string, found bool) <span class="cov8" title="1">{
        res, found := tc.cache.Get(clientId)
        if !found </span><span class="cov8" title="1">{
                return "", false
        }</span>

        <span class="cov8" title="1">return res.(string), found</span>
}

func (tc *tokenCache) Add(clientID, token string, expirationSeconds int) <span class="cov8" title="1">{
        tc.cache.Set(clientID, token, time.Duration(expirationSeconds-2)*time.Second)
}</span>

func (tc *tokenCache) Remove(clientID string) <span class="cov8" title="1">{
        tc.cache.Delete(clientID)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package authorization

import (
        "fmt"
        "net/http"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        "github.com/kyma-project/kyma/components/application-gateway/internal/httpconsts"
        log "github.com/sirupsen/logrus"
)

type oauthStrategy struct {
        oauthClient  OAuthClient
        clientId     string
        clientSecret string
        url          string
}

func newOAuthStrategy(oauthClient OAuthClient, clientId, clientSecret, url string) oauthStrategy <span class="cov8" title="1">{
        return oauthStrategy{
                oauthClient:  oauthClient,
                clientId:     clientId,
                clientSecret: clientSecret,
                url:          url,
        }
}</span>

func (o oauthStrategy) AddAuthorization(r *http.Request, _ TransportSetter) apperrors.AppError <span class="cov8" title="1">{
        token, err := o.oauthClient.GetToken(o.clientId, o.clientSecret, o.url)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("failed to get token : '%s'", err)
                return err
        }</span>

        <span class="cov8" title="1">r.Header.Set(httpconsts.HeaderAuthorization, fmt.Sprintf("Bearer %s", token))

        return nil</span>
}

func (o oauthStrategy) Invalidate() <span class="cov8" title="1">{
        o.oauthClient.InvalidateTokenCache(o.clientId)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package externalapi

import (
        "encoding/json"
        "net/http"

        "github.com/kyma-project/kyma/components/application-gateway/internal/httpconsts"
        "github.com/kyma-project/kyma/components/application-gateway/internal/httperrors"
)

type ErrorHandler struct {
        Message string
        Code    int
}

func NewErrorHandler(code int, message string) *ErrorHandler <span class="cov8" title="1">{
        return &amp;ErrorHandler{Message: message, Code: code}
}</span>

func (eh *ErrorHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        responseBody := httperrors.ErrorResponse{Code: eh.Code, Error: eh.Message}

        w.Header().Set(httpconsts.HeaderContentType, httpconsts.ContentTypeApplicationJson)
        w.WriteHeader(eh.Code)
        json.NewEncoder(w).Encode(responseBody)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package externalapi

import (
        "net/http"

        "github.com/gorilla/mux"
)

func NewHandler() http.Handler <span class="cov0" title="0">{
        router := mux.NewRouter()

        router.Path("/v1/health").Handler(NewHealthCheckHandler()).Methods(http.MethodGet)

        router.NotFoundHandler = NewErrorHandler(404, "Requested resource could not be found.")
        router.MethodNotAllowedHandler = NewErrorHandler(405, "Method not allowed.")

        return router
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package externalapi

import (
        "net/http"
)

// NewHealthCheckHandler creates handler for performing health check
func NewHealthCheckHandler() http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusOK)
        }</span>)
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package k8sconsts

import (
        "fmt"
        "strings"
)

const (
        resourceNamePrefixFormat = "app-%s-"

        maxResourceNameLength = 63 // Kubernetes limit for services
        uuidLength            = 36 // UUID has 36 characters
)

// NameResolver provides names for Kubernetes resources
type NameResolver interface {
        // GetResourceName returns resource name with given ID
        GetResourceName(id string) string
        // ExtractServiceId extracts service ID from given host
        ExtractServiceId(host string) string
}

type nameResolver struct {
        resourceNamePrefix string
}

// NewNameResolver creates NameResolver that uses application name and namespace.
func NewNameResolver(application string) NameResolver <span class="cov8" title="1">{
        return nameResolver{
                resourceNamePrefix: getResourceNamePrefix(application),
        }
}</span>

// GetResourceName returns resource name with given ID
func (resolver nameResolver) GetResourceName(id string) string <span class="cov8" title="1">{
        return resolver.resourceNamePrefix + id
}</span>

// ExtractServiceId extracts service ID from given host
func (resolver nameResolver) ExtractServiceId(host string) string <span class="cov8" title="1">{
        resourceName := strings.Split(host, ".")[0]
        return strings.TrimPrefix(resourceName, resolver.resourceNamePrefix)
}</span>

func getResourceNamePrefix(application string) string <span class="cov8" title="1">{
        truncatedApplication := truncateApplication(application)
        return fmt.Sprintf(resourceNamePrefixFormat, truncatedApplication)
}</span>

func truncateApplication(application string) string <span class="cov8" title="1">{
        maxResourceNamePrefixLength := maxResourceNameLength - uuidLength
        testResourceNamePrefix := fmt.Sprintf(resourceNamePrefixFormat, application)
        testResourceNamePrefixLength := len(testResourceNamePrefix)

        overflowLength := testResourceNamePrefixLength - maxResourceNamePrefixLength

        if overflowLength &gt; 0 </span><span class="cov8" title="1">{
                newApplicationLength := len(application) - overflowLength
                return application[0:newApplicationLength]
        }</span>
        <span class="cov8" title="1">return application</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package application contains components for accessing/modifying Application CRD
package applications

import (
        "fmt"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        "github.com/kyma-project/kyma/components/application-operator/pkg/apis/applicationconnector/v1alpha1"
        log "github.com/sirupsen/logrus"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        specAPIType    = "API"
        specEventsType = "Events"
)

// Manager contains operations for managing Application CRD
type Manager interface {
        Get(name string, options v1.GetOptions) (*v1alpha1.Application, error)
}

type repository struct {
        name       string
        appManager Manager
}

type Credentials struct {
        Type                 string
        SecretName           string
        Url                  string
        CSRFTokenEndpointURL string
}

// ServiceAPI stores information needed to call an API
type ServiceAPI struct {
        GatewayURL  string
        AccessLabel string
        TargetUrl   string
        Credentials *Credentials
}

// Service represents a service stored in Application
type Service struct {
        // Mapped to id in Application CRD
        ID string
        // Mapped to displayName in Application CRD
        DisplayName string
        // Mapped to longDescription in Application CRD
        LongDescription string
        // Mapped to providerDisplayName in Application CRD
        ProviderDisplayName string
        // Mapped to tags in Application CRD
        Tags []string
        // Mapped to type property under entries element (type: API)
        API *ServiceAPI
        // Mapped to type property under entries element (type: Events)
        Events bool
}

// ServiceRepository contains operations for managing services stored in Application CRD
type ServiceRepository interface {
        Get(id string) (Service, apperrors.AppError)
}

// NewServiceRepository creates a new ApplicationServiceRepository
func NewServiceRepository(name string, appManager Manager) ServiceRepository <span class="cov8" title="1">{
        return &amp;repository{name: name, appManager: appManager}
}</span>

// Get reads Service from Application by service id
func (r *repository) Get(id string) (Service, apperrors.AppError) <span class="cov8" title="1">{
        app, err := r.getApplication()
        if err != nil </span><span class="cov0" title="0">{
                return Service{}, err
        }</span>

        <span class="cov8" title="1">for _, service := range app.Spec.Services </span><span class="cov8" title="1">{
                if service.ID == id </span><span class="cov8" title="1">{
                        return convertFromK8sType(service)
                }</span>
        }

        <span class="cov8" title="1">message := fmt.Sprintf("Service with ID %s not found", id)
        log.Warn(message)

        return Service{}, apperrors.NotFound(message)</span>
}

func (r *repository) getApplication() (*v1alpha1.Application, apperrors.AppError) <span class="cov8" title="1">{
        app, err := r.appManager.Get(r.name, v1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if k8serrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        message := fmt.Sprintf("Application: %s not found.", r.name)
                        log.Warn(message)
                        return nil, apperrors.Internal(message)
                }</span>

                <span class="cov0" title="0">message := fmt.Sprintf("failed to get Application '%s' : %s", r.name, err.Error())
                log.Error(message)
                return nil, apperrors.Internal(message)</span>
        }

        <span class="cov8" title="1">return app, nil</span>
}

func convertFromK8sType(service v1alpha1.Service) (Service, apperrors.AppError) <span class="cov8" title="1">{
        var api *ServiceAPI
        var events bool
        </span><span class="cov8" title="1">{
                for _, entry := range service.Entries </span><span class="cov8" title="1">{
                        if entry.Type == specAPIType </span><span class="cov8" title="1">{
                                api = &amp;ServiceAPI{
                                        GatewayURL:  entry.GatewayUrl,
                                        AccessLabel: entry.AccessLabel,
                                        TargetUrl:   entry.TargetUrl,
                                        Credentials: convertCredentialsFromK8sType(entry.Credentials),
                                }
                        }</span><span class="cov0" title="0"> else if entry.Type == specEventsType </span><span class="cov0" title="0">{
                                events = true
                        }</span><span class="cov0" title="0"> else {
                                message := fmt.Sprintf("incorrect type of entry '%s' in Application Service definition", entry.Type)
                                log.Error(message)
                                return Service{}, apperrors.Internal(message)
                        }</span>
                }
        }

        <span class="cov8" title="1">return Service{
                ID:                  service.ID,
                DisplayName:         service.DisplayName,
                LongDescription:     service.LongDescription,
                ProviderDisplayName: service.ProviderDisplayName,
                Tags:                service.Tags,
                API:                 api,
                Events:              events,
        }, nil</span>
}

func convertCredentialsFromK8sType(credentials v1alpha1.Credentials) *Credentials <span class="cov8" title="1">{
        emptyCredentials := v1alpha1.Credentials{}
        if credentials == emptyCredentials </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">csrfTokenEndpointURL := ""
        if credentials.CSRFInfo != nil </span><span class="cov0" title="0">{
                csrfTokenEndpointURL = credentials.CSRFInfo.TokenEndpointURL
        }</span>

        <span class="cov8" title="1">return &amp;Credentials{
                Type:                 credentials.Type,
                SecretName:           credentials.SecretName,
                Url:                  credentials.AuthenticationUrl,
                CSRFTokenEndpointURL: csrfTokenEndpointURL,
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package secrets contains components for accessing/modifying client secrets
package secrets

import (
        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        log "github.com/sirupsen/logrus"
        v1 "k8s.io/api/core/v1"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Repository contains operations for managing client credentials
type Repository interface {
        Get(name string) (map[string][]byte, apperrors.AppError)
}

type repository struct {
        secretsManager Manager
        application    string
}

// Manager contains operations for managing k8s secrets
type Manager interface {
        Get(name string, options metav1.GetOptions) (*v1.Secret, error)
}

// NewRepository creates a new secrets repository
func NewRepository(secretsManager Manager, application string) Repository <span class="cov8" title="1">{
        return &amp;repository{
                secretsManager: secretsManager,
                application:    application,
        }
}</span>

func (r *repository) Get(name string) (map[string][]byte, apperrors.AppError) <span class="cov8" title="1">{
        secret, err := r.secretsManager.Get(name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("failed to read secret '%s': %s", name, err.Error())
                if k8serrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return nil, apperrors.NotFound("secret '%s' not found", name)
                }</span>
                <span class="cov8" title="1">return nil, apperrors.Internal("failed to get '%s' secret, %s", name, err)</span>
        }

        <span class="cov8" title="1">return secret.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package serviceapi

import (
        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        "github.com/kyma-project/kyma/components/application-gateway/internal/metadata/applications"
        "github.com/kyma-project/kyma/components/application-gateway/internal/metadata/model"
        "github.com/kyma-project/kyma/components/application-gateway/internal/metadata/secrets"
)

const (
        ClientIDKey        = "clientId"
        ClientSecretKey    = "clientSecret"
        UsernameKey        = "username"
        PasswordKey        = "password"
        TypeOAuth          = "OAuth"
        TypeBasic          = "Basic"
        TypeCertificateGen = "CertificateGen"
        PrivateKeyKey      = "key"
        CertificateKey     = "crt"
        CommonNameKey      = "commonName"
)

// Service manages API definition of a service
type Service interface {
        // Read reads API from Application API definition. It also reads all additional information.
        Read(*applications.ServiceAPI) (*model.API, apperrors.AppError)
}

type defaultService struct {
        secretsRepository secrets.Repository
}

func NewService(secretsRepository secrets.Repository) Service <span class="cov8" title="1">{

        return defaultService{
                secretsRepository: secretsRepository,
        }
}</span>

func (sas defaultService) Read(applicationAPI *applications.ServiceAPI) (*model.API, apperrors.AppError) <span class="cov8" title="1">{
        api := &amp;model.API{
                TargetUrl: applicationAPI.TargetUrl,
        }

        if applicationAPI.Credentials != nil </span><span class="cov8" title="1">{
                credentialsSecretName := applicationAPI.Credentials.SecretName
                credentialsType := applicationAPI.Credentials.Type

                secret, err := sas.secretsRepository.Get(credentialsSecretName)

                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if credentialsType == TypeOAuth </span><span class="cov8" title="1">{
                        api.Credentials = &amp;model.Credentials{
                                OAuth: getOAuthCredentials(secret, applicationAPI.Credentials.Url),
                        }
                        api.Credentials.CSRFTokenEndpointURL = applicationAPI.Credentials.CSRFTokenEndpointURL
                }</span><span class="cov8" title="1"> else if credentialsType == TypeBasic </span><span class="cov8" title="1">{
                        api.Credentials = &amp;model.Credentials{
                                BasicAuth: getBasicAuthCredentials(secret),
                        }
                        api.Credentials.CSRFTokenEndpointURL = applicationAPI.Credentials.CSRFTokenEndpointURL
                }</span><span class="cov8" title="1"> else if credentialsType == TypeCertificateGen </span><span class="cov8" title="1">{
                        api.Credentials = &amp;model.Credentials{
                                CertificateGen: getCertificateGenCredentials(secret),
                        }
                        api.Credentials.CSRFTokenEndpointURL = applicationAPI.Credentials.CSRFTokenEndpointURL
                }</span><span class="cov0" title="0"> else {
                        api.Credentials = nil
                }</span>
        }

        <span class="cov8" title="1">return api, nil</span>
}

func getOAuthCredentials(secret map[string][]byte, url string) *model.OAuth <span class="cov8" title="1">{
        return &amp;model.OAuth{
                ClientID:     string(secret[ClientIDKey]),
                ClientSecret: string(secret[ClientSecretKey]),
                URL:          url,
        }
}</span>

func getBasicAuthCredentials(secret map[string][]byte) *model.BasicAuth <span class="cov8" title="1">{
        return &amp;model.BasicAuth{
                Username: string(secret[UsernameKey]),
                Password: string(secret[PasswordKey]),
        }
}</span>

func getCertificateGenCredentials(secret map[string][]byte) *model.CertificateGen <span class="cov8" title="1">{
        return &amp;model.CertificateGen{
                CommonName:  string(secret[CommonNameKey]),
                Certificate: secret[CertificateKey],
                PrivateKey:  secret[PrivateKeyKey],
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package metadata contains components for accessing Kyma storage (Application, Minio)
package metadata

import (
        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        "github.com/kyma-project/kyma/components/application-gateway/internal/metadata/applications"
        "github.com/kyma-project/kyma/components/application-gateway/internal/metadata/model"
        "github.com/kyma-project/kyma/components/application-gateway/internal/metadata/serviceapi"
        log "github.com/sirupsen/logrus"
)

// ServiceDefinitionService is a service that manages ServiceDefinition objects.
type ServiceDefinitionService interface {
        // GetAPI gets API of a service with given ID
        GetAPI(serviceId string) (*model.API, apperrors.AppError)
}

type serviceDefinitionService struct {
        serviceAPIService     serviceapi.Service
        applicationRepository applications.ServiceRepository
}

// NewServiceDefinitionService creates new ServiceDefinitionService with provided dependencies.
func NewServiceDefinitionService(serviceAPIService serviceapi.Service, applicationRepository applications.ServiceRepository) ServiceDefinitionService <span class="cov8" title="1">{
        return &amp;serviceDefinitionService{
                serviceAPIService:     serviceAPIService,
                applicationRepository: applicationRepository,
        }
}</span>

// GetAPI gets API of a service with given ID
func (sds *serviceDefinitionService) GetAPI(serviceId string) (*model.API, apperrors.AppError) <span class="cov8" title="1">{
        service, err := sds.applicationRepository.Get(serviceId)
        if err != nil </span><span class="cov8" title="1">{
                if err.Code() == apperrors.CodeNotFound </span><span class="cov8" title="1">{
                        return nil, apperrors.NotFound("service with ID %s not found", serviceId)
                }</span>
                <span class="cov8" title="1">log.Errorf("failed to get service with id '%s': %s", serviceId, err.Error())
                return nil, apperrors.Internal("failed to read %s service, %s", serviceId, err)</span>
        }

        <span class="cov8" title="1">if service.API == nil </span><span class="cov8" title="1">{
                return nil, apperrors.WrongInput("service with ID '%s' has no API", serviceId)
        }</span>

        <span class="cov8" title="1">api, err := sds.serviceAPIService.Read(service.API)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("failed to read api for serviceId '%s': %s", serviceId, err.Error())
                return nil, apperrors.Internal("failed to read API for %s service, %s", serviceId, err)
        }</span>
        <span class="cov8" title="1">return api, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package proxy

import (
        "net/http"
        "net/http/httputil"
        "time"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        "github.com/kyma-project/kyma/components/application-gateway/internal/authorization"
        "github.com/kyma-project/kyma/components/application-gateway/internal/authorization/csrf"
        gocache "github.com/patrickmn/go-cache"
)

const cleanupInterval = 60

type CacheEntry struct {
        Proxy                 *httputil.ReverseProxy
        AuthorizationStrategy *authorizationStrategyWrapper
        CSRFTokenStrategy     csrf.TokenStrategy
}

type authorizationStrategyWrapper struct {
        actualStrategy authorization.Strategy
        proxy          *httputil.ReverseProxy
}

func (ce *authorizationStrategyWrapper) AddAuthorization(r *http.Request) apperrors.AppError <span class="cov8" title="1">{

        ts := func(transport *http.Transport) </span><span class="cov0" title="0">{
                ce.proxy.Transport = transport
        }</span>

        <span class="cov8" title="1">return ce.actualStrategy.AddAuthorization(r, ts)</span>
}

func (ce *authorizationStrategyWrapper) Invalidate() <span class="cov8" title="1">{
        ce.actualStrategy.Invalidate()
}</span>

type Cache interface {
        // Get returns entry from the cache
        Get(id string) (*CacheEntry, bool)
        // Put adds entry to the cache
        Put(id string, reverseProxy *httputil.ReverseProxy, authorizationStrategy authorization.Strategy, csrfTokenStrategy csrf.TokenStrategy) *CacheEntry
}

type cache struct {
        proxyCache *gocache.Cache
}

// NewCache creates new cache with specified TTL
func NewCache(proxyCacheTTL int) Cache <span class="cov8" title="1">{
        return &amp;cache{
                proxyCache: gocache.New(time.Duration(proxyCacheTTL)*time.Second, cleanupInterval*time.Second),
        }
}</span>

func (p *cache) Get(id string) (*CacheEntry, bool) <span class="cov8" title="1">{
        proxy, found := p.proxyCache.Get(id)
        if !found </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">return proxy.(*CacheEntry), found</span>
}

func (p *cache) Put(id string, reverseProxy *httputil.ReverseProxy, authorizationStrategy authorization.Strategy, csrfTokenStrategy csrf.TokenStrategy) *CacheEntry <span class="cov8" title="1">{

        proxy := &amp;CacheEntry{Proxy: reverseProxy, AuthorizationStrategy: &amp;authorizationStrategyWrapper{authorizationStrategy, reverseProxy}, CSRFTokenStrategy: csrfTokenStrategy}
        p.proxyCache.Set(id, proxy, gocache.DefaultExpiration)

        return proxy
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package proxy

import (
        "context"
        "encoding/json"
        "net/http"
        "time"

        "github.com/kyma-project/kyma/components/application-gateway/internal/authorization/csrf"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        "github.com/kyma-project/kyma/components/application-gateway/internal/authorization"
        "github.com/kyma-project/kyma/components/application-gateway/internal/httpconsts"
        "github.com/kyma-project/kyma/components/application-gateway/internal/httperrors"
        "github.com/kyma-project/kyma/components/application-gateway/internal/k8sconsts"
        "github.com/kyma-project/kyma/components/application-gateway/internal/metadata"
        metadatamodel "github.com/kyma-project/kyma/components/application-gateway/internal/metadata/model"
)

type proxy struct {
        nameResolver                 k8sconsts.NameResolver
        serviceDefService            metadata.ServiceDefinitionService
        cache                        Cache
        skipVerify                   bool
        proxyTimeout                 int
        authorizationStrategyFactory authorization.StrategyFactory
        csrfTokenStrategyFactory     csrf.TokenStrategyFactory
}

type Config struct {
        SkipVerify    bool
        ProxyTimeout  int
        Application   string
        ProxyCacheTTL int
}

// New creates proxy for handling user's services calls
func New(serviceDefService metadata.ServiceDefinitionService, authorizationStrategyFactory authorization.StrategyFactory, csrfTokenStrategyFactory csrf.TokenStrategyFactory, config Config) http.Handler <span class="cov8" title="1">{
        return &amp;proxy{
                nameResolver:                 k8sconsts.NewNameResolver(config.Application),
                serviceDefService:            serviceDefService,
                cache:                        NewCache(config.ProxyCacheTTL),
                skipVerify:                   config.SkipVerify,
                proxyTimeout:                 config.ProxyTimeout,
                authorizationStrategyFactory: authorizationStrategyFactory,
                csrfTokenStrategyFactory:     csrfTokenStrategyFactory,
        }
}</span>

// NewInvalidStateHandler creates handler always returning 500 response
func NewInvalidStateHandler(message string) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                handleErrors(w, apperrors.Internal(message))
        }</span>)
}

func (p *proxy) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id := p.extractServiceId(r.Host)

        cacheEntry, err := p.getOrCreateCacheEntry(id)
        if err != nil </span><span class="cov8" title="1">{
                handleErrors(w, err)
                return
        }</span>

        <span class="cov8" title="1">newRequest, cancel := p.prepareRequest(r, cacheEntry)
        defer cancel()

        err = p.addAuthorization(newRequest, cacheEntry)
        if err != nil </span><span class="cov8" title="1">{
                handleErrors(w, err)
                return
        }</span>

        <span class="cov8" title="1">p.addModifyResponseHandler(newRequest, id, cacheEntry)

        p.executeRequest(w, newRequest, cacheEntry)</span>
}

func (p *proxy) extractServiceId(host string) string <span class="cov8" title="1">{
        return p.nameResolver.ExtractServiceId(host)
}</span>

func (p *proxy) getOrCreateCacheEntry(id string) (*CacheEntry, apperrors.AppError) <span class="cov8" title="1">{
        cacheObj, found := p.cache.Get(id)

        if found </span><span class="cov8" title="1">{
                return cacheObj, nil
        }</span><span class="cov8" title="1"> else {
                return p.createCacheEntry(id)
        }</span>
}

func (p *proxy) createCacheEntry(id string) (*CacheEntry, apperrors.AppError) <span class="cov8" title="1">{
        serviceApi, err := p.serviceDefService.GetAPI(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">proxy, err := makeProxy(serviceApi.TargetUrl, id, p.skipVerify)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">authorizationStrategy := p.newAuthorizationStrategy(serviceApi.Credentials)
        csrfTokenStrategy := p.newCSRFTokenStrategy(authorizationStrategy, serviceApi.Credentials)

        return p.cache.Put(id, proxy, authorizationStrategy, csrfTokenStrategy), nil</span>
}

func (p *proxy) newAuthorizationStrategy(credentials *metadatamodel.Credentials) authorization.Strategy <span class="cov8" title="1">{
        return p.authorizationStrategyFactory.Create(credentials)
}</span>

func (p *proxy) newCSRFTokenStrategy(authorizationStrategy authorization.Strategy, credentials *metadatamodel.Credentials) csrf.TokenStrategy <span class="cov8" title="1">{
        csrfTokenEndpointURL := ""
        if credentials != nil </span><span class="cov8" title="1">{
                csrfTokenEndpointURL = credentials.CSRFTokenEndpointURL
        }</span>
        <span class="cov8" title="1">return p.csrfTokenStrategyFactory.Create(authorizationStrategy, csrfTokenEndpointURL)</span>
}

func (p *proxy) prepareRequest(r *http.Request, cacheEntry *CacheEntry) (*http.Request, context.CancelFunc) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), time.Duration(p.proxyTimeout)*time.Second)
        newRequest := r.WithContext(ctx)

        return newRequest, cancel
}</span>

func (p *proxy) addAuthorization(r *http.Request, cacheEntry *CacheEntry) apperrors.AppError <span class="cov8" title="1">{

        err := cacheEntry.AuthorizationStrategy.AddAuthorization(r)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return cacheEntry.CSRFTokenStrategy.AddCSRFToken(r)</span>
}

func (p *proxy) addModifyResponseHandler(r *http.Request, id string, cacheEntry *CacheEntry) <span class="cov8" title="1">{
        cacheEntry.Proxy.ModifyResponse = p.createModifyResponseFunction(id, r)
}</span>

func (p *proxy) createModifyResponseFunction(id string, r *http.Request) func(*http.Response) error <span class="cov8" title="1">{
        // Handle the case when credentials has been changed or OAuth token has expired
        return func(response *http.Response) error </span><span class="cov8" title="1">{
                retrier := newUnauthorizedResponseRetrier(id, r, p.proxyTimeout, p.createCacheEntry)

                return retrier.RetryIfFailedToAuthorize(response)
        }</span>
}

func (p *proxy) executeRequest(w http.ResponseWriter, r *http.Request, cacheEntry *CacheEntry) <span class="cov8" title="1">{
        cacheEntry.Proxy.ServeHTTP(w, r)
}</span>

func handleErrors(w http.ResponseWriter, apperr apperrors.AppError) <span class="cov8" title="1">{
        code, body := httperrors.AppErrorToResponse(apperr)
        respondWithBody(w, code, body)
}</span>

func respondWithBody(w http.ResponseWriter, code int, body httperrors.ErrorResponse) <span class="cov8" title="1">{
        w.Header().Set(httpconsts.HeaderContentType, httpconsts.ContentTypeApplicationJson)

        w.WriteHeader(code)

        json.NewEncoder(w).Encode(body)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package proxy

import (
        "crypto/tls"
        "net/http"
        "net/http/httputil"
        "net/url"
        "strings"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        log "github.com/sirupsen/logrus"
)

func makeProxy(targetUrl string, id string, skipVerify bool) (*httputil.ReverseProxy, apperrors.AppError) <span class="cov8" title="1">{
        target, err := url.Parse(targetUrl)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to parse target url '%s': '%s'", targetUrl, err.Error())
                return nil, apperrors.Internal("failed to parse target url '%s': '%s'", targetUrl, err.Error())
        }</span>

        <span class="cov8" title="1">targetQuery := target.RawQuery
        director := func(req *http.Request) </span><span class="cov8" title="1">{
                log.Infof("Proxy call for service '%s' to '%s'", id, targetUrl)
                req.URL.Scheme = target.Scheme
                req.URL.Host = target.Host
                req.Host = target.Host

                req.URL.Path = joinPaths(target.Path, req.URL.Path)

                if targetQuery == "" || req.URL.RawQuery == "" </span><span class="cov8" title="1">{
                        req.URL.RawQuery = targetQuery + req.URL.RawQuery
                }</span><span class="cov0" title="0"> else {
                        req.URL.RawQuery = targetQuery + "&amp;" + req.URL.RawQuery
                }</span>
                <span class="cov8" title="1">if _, ok := req.Header["User-Agent"]; !ok </span><span class="cov8" title="1">{
                        // explicitly disable User-Agent so it's not set to default value
                        req.Header.Set("User-Agent", "")
                }</span>
                <span class="cov8" title="1">log.Infof("Modified request url : '%s', schema : '%s', path : '%s'", req.URL.String(), req.URL.Scheme, req.URL.Path)</span>
        }
        <span class="cov8" title="1">newProxy := &amp;httputil.ReverseProxy{Director: director}

        newProxy.Transport = &amp;http.Transport{TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: skipVerify}}

        return newProxy, nil</span>
}

func joinPaths(a, b string) string <span class="cov8" title="1">{
        if b == "" </span><span class="cov0" title="0">{
                return a
        }</span>

        <span class="cov8" title="1">aslash := strings.HasSuffix(a, "/")
        bslash := strings.HasPrefix(b, "/")
        switch </span>{
        case aslash &amp;&amp; bslash:<span class="cov0" title="0">
                return a + b[1:]</span>
        case !aslash &amp;&amp; !bslash:<span class="cov0" title="0">
                return a + "/" + b</span>
        }
        <span class="cov8" title="1">return a + b</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package proxy

import (
        "context"
        "net/http"
        "time"

        "github.com/kyma-project/kyma/components/application-gateway/internal/apperrors"
        log "github.com/sirupsen/logrus"
)

type retrier struct {
        id                       string
        request                  *http.Request
        retried                  bool
        timeout                  int
        updateCacheEntryFunction updateCacheEntryFunction
}

type updateCacheEntryFunction = func(string) (*CacheEntry, apperrors.AppError)

func newUnauthorizedResponseRetrier(id string, request *http.Request, timeout int, updateCacheEntryFunc updateCacheEntryFunction) *retrier <span class="cov8" title="1">{
        return &amp;retrier{id: id, request: request, retried: false, timeout: timeout, updateCacheEntryFunction: updateCacheEntryFunc}
}</span>

func (rr *retrier) RetryIfFailedToAuthorize(r *http.Response) error <span class="cov8" title="1">{
        if rr.retried </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">rr.retried = true

        if r.StatusCode == http.StatusForbidden || r.StatusCode == http.StatusUnauthorized </span><span class="cov8" title="1">{
                log.Infof("Request from service with id %s failed with %d status, invalidating proxy and retrying.", rr.id, r.StatusCode)

                res, err := rr.retry()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if res != nil </span><span class="cov8" title="1">{
                        if r.Body != nil </span><span class="cov8" title="1">{
                                r.Body.Close()
                        }</span>
                        <span class="cov8" title="1">*r = *res</span>
                }

        }

        <span class="cov8" title="1">return nil</span>
}

func (rr *retrier) retry() (*http.Response, error) <span class="cov8" title="1">{
        request, cancel := rr.prepareRequest()
        defer cancel()

        var err error

        cacheEntry, err := rr.updateCacheEntryFunction(rr.id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = rr.addAuthorization(request, cacheEntry)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return rr.performRequest(request, cacheEntry)</span>
}

func (rr *retrier) prepareRequest() (*http.Request, context.CancelFunc) <span class="cov8" title="1">{
        rr.request.RequestURI = ""
        ctx, cancel := context.WithTimeout(context.Background(), time.Duration(rr.timeout)*time.Second)

        return rr.request.WithContext(ctx), cancel
}</span>

func (rr *retrier) addAuthorization(r *http.Request, cacheEntry *CacheEntry) error <span class="cov8" title="1">{
        authorizationStrategy := cacheEntry.AuthorizationStrategy
        authorizationStrategy.Invalidate()
        err := cacheEntry.AuthorizationStrategy.AddAuthorization(r)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">csrfTokenStrategy := cacheEntry.CSRFTokenStrategy
        csrfTokenStrategy.Invalidate()
        return csrfTokenStrategy.AddCSRFToken(r)</span>
}

func (rr *retrier) performRequest(r *http.Request, cacheEntry *CacheEntry) (*http.Response, error) <span class="cov8" title="1">{
        reverseProxy := cacheEntry.Proxy
        reverseProxy.Director(r)

        client := &amp;http.Client{
                Transport: reverseProxy.Transport,
        }

        res, err := client.Do(r)

        return res, err
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
